package com.akiradunn.oj.leetcode.dp;
//764. 最大加号标志
//在一个大小在 (0, 0) 到 (N-1, N-1) 的2D网格 grid 中，除了在 mines 中给出的单元为 0，其他每个单元都是 1。网格中包含 1 的最大的轴对齐加号标志是多少阶？返回加号标志的阶数。如果未找到加号标志，则返回 0。
//
//一个 k" 阶由 1 组成的“轴对称”加号标志具有中心网格  grid[x][y] = 1 ，以及4个从中心向上、向下、向左、向右延伸，长度为 k-1，由 1 组成的臂。下面给出 k" 阶“轴对称”加号标志的示例。注意，只有加号标志的所有网格要求为 1，别的网格可能为 0 也可能为 1。
//
//
//
//k 阶轴对称加号标志示例:
//
//阶 1:
//000
//010
//000
//
//阶 2:
//00000
//00100
//01110
//00100
//00000
//
//阶 3:
//0000000
//0001000
//0001000
//0111110
//0001000
//0001000
//0000000
//
//
//示例 1：
//
//输入: N = 5, mines = [[4, 2]]
//输出: 2
//解释:
//
//11111
//11111
//11111
//11111
//11011
//
//在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。
//
//
//示例 2：
//
//输入: N = 2, mines = []
//输出: 1
//解释:
//
//11
//11
//
//没有 2 阶加号标志，有 1 阶加号标志。
//
//
//示例 3：
//
//输入: N = 1, mines = [[0, 0]]
//输出: 0
//解释:
//
//0
//
//没有加号标志，返回 0 。
//
//
//提示：
//
//整数N 的范围： [1, 500].
//mines 的最大长度为 5000.
//mines[i] 是长度为2的由2个 [0, N-1] 中的数组成.
//(另外,使用 C, C++, 或者 C# 编程将以稍小的时间限制进行​​判断.)
//
//
//通过次数3,331提交次数6,880
public class ALISolution764 {
    class Solution {
        public int orderOfLargestPlusSign(int N, int[][] mines) {
            int[][][] f = new int[N][N][4];
            //初始化0
            for(int i=0; i<N; i++){
                for(int j=0; j<N; j++){
                    for(int k=0; k<4; k++){
                        f[i][j][k] = 1;
                    }
                }
            }

            //初始化1
            for(int[] mine : mines){
                for(int k=0; k<4; k++){
                    f[mine[0]][mine[1]][k] = 0;
                }
            }

            //初始化2, 优秀的初始化避免数组指针越界
            for(int i=1; i<N; i++){
                for(int j=1; j<N; j++){
                    //此处判断可以使f[i][j][k],k<4的任意一个，代表是否(i,j)是0节点
                    if(f[i][j][1] == 0) continue;
                    f[i][j][0] = f[i][j-1][0] + 1;
                    f[i][j][1] = f[i-1][j][1] + 1;
                }
            }

            //初始化3, 优秀的初始化避免数组指针越界
            for(int i=N-2; i>=0; i--){
                for(int j=N-2; j>=0; j--){
                    //此处判断可以使f[i][j][k],k<4的任意一个，代表是否(i,j)是0节点
                    if(f[i][j][3] == 0) continue;
                    f[i][j][2] = f[i][j+1][2] + 1;
                    f[i][j][3] = f[i+1][j][3] + 1;
                }
            }

            //求解
            int res = 0;
            for(int i=0; i<N; i++){
                for(int j=0; j<N; j++){
                    int min = Math.min(f[i][j][0], Math.min(f[i][j][1], Math.min(f[i][j][2], f[i][j][3])));
                    res = Math.max(res, min);
                }
            }

            return res;
        }
    }
}
